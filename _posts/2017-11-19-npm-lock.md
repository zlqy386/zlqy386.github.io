---
layout: post
title:  npm版本固化
date:   2017-11-19
lastUpdate: 2017-11-26
tags:
- npm
- yarn
- 版本固化
---
在项目开发中，我们需要管理复杂的项目依赖。npm包版本的标准基于[semver](https://semver.org/){:target="_blank"}[^1]，它为依赖的升级提供了便利，但也导致了安装依赖的不一致性。出于以下考虑，我们需要版本固化方案锁定依赖的版本：

1. 保证不同环境，不同机器下依赖安装的一致性，
2. 避免某些依赖的更新引入新的bug。

目前的版本固化方案有[npm shrinkwrap](https://docs.npmjs.com/cli/shrinkwrap){:target="_blank"}，[yarn](https://yarnpkg.com/){:target="_blank"}以及[npm package-lock](https://docs.npmjs.com/files/package-locks){:target="_blank"}。

## npm shrinkwrap

### 版本固化

通过执行命令`npm shrinkwrap`，可以根据`node_modules`目录下的依赖生成名为`npm-shrinkwrap.json`的文件。这个文件描述了安装依赖所需要的基本信息，之后执行`npm install`就可根据这个文件生成同样的`node_modules`目录。

以`npm@4.2.0`为例:

```javascript
{
  "name": "test",
  "version": "1.0.0",
  ...
  "dependencies": {
    "path-to-regexp": "^1.7.0"
  },
  "devDependencies": {},
  ...
}
```

以上的`package.json`会生成如下的`npm-shrinkwrap.json`：

```javascript
{
  "name": "test",
  "version": "1.0.0",
  "dependencies": {
    "isarray": {
      "version": "0.0.1",
      "from": "isarray@0.0.1",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-0.0.1.tgz"
    },
    "path-to-regexp": {
      "version": "1.7.0",
      "from": "path-to-regexp@>=1.7.0 <2.0.0",
      "resolved": "https://registry.npmjs.org/-/path-to-regexp-1.7.0.tgz"
    }
  }
}
```

当重新安装依赖时，`npm install`会安装`path-to-regexp@1.7.0`及其依赖`isarray@0.01`。

值得一提的是`npm-shrinkwrap.json`中的`dependencies`和`node_modules`下的依赖均为嵌套结构。如有需要可以执行[`npm dedupe`](https://docs.npmjs.com/cli/dedupe){:target="_blank"}来去除重复的包，使依赖树尽量扁平化。

### 更新依赖

可以使用`npm update`更新相应依赖，随后需要手动重新生成`npm-shrinkwrap.json`。

也可以执行`npm install <name>@<version> --save`安装指定版本依赖，该指令会自动更新`npm-shrinkwrap.json`。

## yarn

当使用yarn安装依赖时，会自动生成[`yarn.lock`](https://yarnpkg.com/lang/en/docs/yarn-lock/){:target="_blank"}，这个文件保存了每个依赖的版本号以及checksum。

同样以上一节的`package.json`为例，生成的`yarn.lock`如下：

```
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

isarray@0.0.1:
  version "0.0.1"
  resolved "https://registry.npmjs.org/isarray/-/isarray-0.0.1.tgz#8a18acfca9a8f4177e09abfc6038939b05d1eedf"

path-to-regexp@^1.7.0:
  version "1.7.0"
  resolved "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-1.7.0.tgz#59fde0f435badacba103a84e9d3bc64e96b9937d"
  dependencies:
    isarray "0.0.1"
```

出于团队协作的考虑，`yarn.lock`中的依赖只有一层，这样可以方便开发者比较差异，解决冲突。但这种扁平化的格式导致仅凭`yarn.lock`并能得知项目的直接依赖，依赖的嵌套关系需要从`package.json`推断，因此yarn能够固化依赖的版本，却不能完全还原`node_modules`中依赖的位置。[^2]

### 更新依赖

当执行`yarn add/upgrade/remove`时，`yarn.lock`会自动更新。也可在`package.json`中增加`resolutions`字段手动指定某个包的依赖。[^3]

## npm package-lock

如果使用npm v5安装依赖，会自动生成`package-lock.json`，其实现同`npm-shrinkwrap.json`相同。之所以用新的文件，是为了便于理解，并能够向后兼容。[^4]

npm v5中，增删了一些`package-lock.json`文件中的字段，以`npm@5.5.1`为例，上述例子生成的`package-lock.json`如下：

```javascript
{
  "name": "test",
  "version": "1.0.0",
  "lockfileVersion": 1,
  "requires": true,
  "dependencies": {
    "isarray": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/isarray/-/isarray-0.0.1.tgz",
      "integrity": "sha1-ihis/Kmo9Bd+Cav8YDiTmwXR7t8="
    },
    "path-to-regexp": {
      "version": "1.7.0",
      "resolved": "https://registry.npmjs.org/path-to-regexp/-/path-to-regexp-1.7.0.tgz",
      "integrity": "sha1-Wf3g9DW62suhA6hOnTvGTpa5k30=",
      "requires": {
        "isarray": "0.0.1"
      }
    }
  }
}
```

关于`package-lock.json`和`npm-shrinkwrap.json`两个文件[^5]，有几点需要注意：
1. 发布npm包时，并不会带上`package-lock.json`
2. 安装或更新npm包时，优先级`npm-shrinkwrap.json` > `package-lock.json`
3. 执行`npm shrinkwrap`时若存在`package-lock.json`，会将其重命名为`npm-shrinkwrap.json`并更新

### 更新依赖

同npm shrinkwrap。注意[npm v5会默认 -\-save](https://twitter.com/maybekatz/status/859229741676625920){:target="_blank"}。

## 总结

对一个项目而言，`package.json`定义了作者期望的依赖及其版本，而`npm-shrinkwrap.json`、`yarn.lock`或者`package-lock.json`则可以视为某次安装后所有的依赖及其版本的快照。

当然，版本固化只是一个技术方案，实际工程中应该权衡后决定是否使用。[^6][^7]

依赖也分为[不同的类型](https://yarnpkg.com/lang/en/docs/dependency-types/){:target="_blank"}，对[optionalDependencies](https://npm.github.io/using-pkgs-docs/package-json/types/optionaldependencies.html){:target="_blank"}，版本固化方案还存在一些问题。[^8][^9]

## 参考链接

[^1]: [Semantic versioning and npm](https://docs.npmjs.com/getting-started/semantic-versioning){:target="_blank"}
[^2]: [Yarn determinism](https://yarnpkg.com/blog/2017/05/31/determinism/){:target="_blank"}
[^3]: [Selective dependency resolutions](https://yarnpkg.com/en/docs/selective-version-resolutions){:target="_blank"}
[^4]: 参见reddit上的这个[回答](https://www.reddit.com/r/javascript/comments/6dgnnq/npm_v500_released_save_by_default_lockfile_better/di3mjuk/){:target="_blank"}
[^5]: [package-lock and npm-shrinkwrap](https://github.com/npm/npm/blob/latest/doc/spec/package-lock.md){:target="_blank"}
[^6]: [为什么我不使用 shrinkwrap（lock）](https://zhuanlan.zhihu.com/p/22934066){:target="_blank"}
[^7]: [Lockfiles should be committed on all projects](https://yarnpkg.com/blog/2016/11/24/lockfiles-for-all/){:target="_blank"}
[^8]: [shrinkwrap and optionalDependencies](https://github.com/npm/npm/issues/2679){:target="_blank"}
[^9]: [-\-ignore-optional doesn't behave like -\-no-optional](https://github.com/yarnpkg/yarn/issues/4665){:target="_blank"}